---
title: "STAT 345 Final Project - Drunken Chessmaster"
author: "STAT 345 - Kirk Dahlke"
output: html_document
---

Expected Submission: You will generate a well-written R Markdown report that addresses the following prompts. This R Markdown report should source your analysis code and only display top-level, abstracted code _if/when appropriate_. Choices made during the analysis project should be described and justified in the report. The written report (knitted file) and your analysis code should be submitted to Canvas by Tuesday, May 13 at 6:45pm. 

Advice for getting started:

- Start a conversation chain with your group members. Email is a great place to start, but other options exist (texting, social media platforms, etc.). Set some reasonable expectations for how and when you plan to respond to conversations. It is likely going to be unacceptable to only respond once per week, for example, but also likely unacceptable to expect a response within the hour. Have an honest conversation with your group members about this issue.
- Start the project from a "top-down design" perspective. So, determine what the major steps of the process are, and determine what the inputs and outputs are for each of those steps (the output of step 1 will likely be the input for step 2, for example). This step is much like writing an outline for a paper before you start to write the paper itself, only much more valuable in a group setting. 
- Once you have a sense of the big picture (the outline), determine some "due dates" for each step of the process. Work backwards from the final submission date, giving yourselves time to work on each of the parts as needed. Given the top-down design, you should be able to "divide and conquer" -- working on parts of the project that depend on earlier steps.
- Decide how you plan to share code with each other. Using Git and GitHub is a really good choice here. If not, perhaps some form of shared directory online. In a worst-case scenario, email could also work. 
- Be prepared to give Dr. Baumann (at least) weekly updates on your progress. Some of this can be done via email, but discuss with your group about times you are each available to meet online as well (in an office-hour-like setting). Feel free to request meetings with Dr. Baumann to get help.

**General advice:** Get started early. If you wait to the last minute, it will not go well. For this project, you may find yourself spending a reasonable amount of time _searching_ for help.

1. _Plan Your Trip_ Imagine playing chess with only one piece by always selecting your next move at random from all possible legal moves. This is something a drunken chessmaster might do! Write a function to simulate this process for each of the "Back Row" pieces (rook, knight, bishop, queen, and king), starting at an arbitrary location and allowing for an arbitrary number of moves.

```{r}
install.packages("rchess")
```

```{r}
library(rchess)
library(rvest)
library(stringr)
chss <- Chess$new()
chss$clear()
chss$moves(verbose = TRUE)
#Purpose: To select a random square to put the chosen piece on
#input: string of "q" for a queen, "k" for a king, "p" for a pawn, "n" for a knight, "r" for a rook, "b" for a bishop
#output: A chess board with a randomly placed piece of the users choice
selector_place <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chss$put(piece, "w", spot)
  plot(chss)
}
#Purpose: To make a random move and then change the color of the piece so as to avoid having to have more that one piece on the board.
#Input: None
#Output: Moves the a chess piece randomly and changes the chess pieces color
selector_move <- function(){
  move_num <- sample(1:length(chss$moves()), 1)
  move_choice <- chss$moves()[move_num]
  chss$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chss$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chss$put(piece_changer$type, color_change, new_square)
  plot(chss)
}
selector_place("b")
selector_move()
```

2. _Popular Destinations_ Use your functions from part 1 to simulate 1000 moves, starting from several different positions. Create a data visualization of the resulting moves (or alternatively, of the resulting positions).

3. _Vacation Duration_ How many moves does it take for each piece to return where it started? Does it matter where you start? Characterize these distributions.

###### Bishop Functions

```{r message=FALSE, warning=FALSE, include=FALSE}
chssB <- Chess$new()
chssB$clear()
chssB$moves(verbose = TRUE)

selector_placeB <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chssB$put(piece, "w", spot)
  plot(chssB)
}

selector_moveB <- function(){
  move_num <- sample(1:length(chssB$moves()), 1)
  move_choice <- chssB$moves()[move_num]
  chssB$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chssB$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chssB$put(piece_changer$type, color_change, new_square)
  plot(chssB)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
selector_placeB("b")
replicate(1000, selector_moveB()) ## Repeats moves 1000 times
bishop_position <- chssB$history(verbose = TRUE) ## Creates data frame to track position
bishopDf <- subset(bishop_position, to == from[1])
originalBishop <- bishopDf[1,7]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
originalBishop
```

###### Rook Functions

```{r message=FALSE, warning=FALSE, include=FALSE}
chssR <- Chess$new()
chssR$clear()
chssR$moves(verbose = TRUE)

selector_placeR <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chssR$put(piece, "w", spot)
  plot(chssR)
}

selector_moveR <- function(){
  move_num <- sample(1:length(chssR$moves()), 1)
  move_choice <- chssR$moves()[move_num]
  chssR$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chssR$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chssR$put(piece_changer$type, color_change, new_square)
  plot(chssR)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
selector_placeR("r")
replicate(1000, selector_moveR()) ## Repeats moves 1000 times
rook_position <- chssR$history(verbose = TRUE) ## Creates data frame to track
rookDf <- subset(rook_position, to == from[1])
originalRook <- rookDf[1,7]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
originalRook
```

###### Knight Functions

```{r message=FALSE, warning=FALSE, include=FALSE}
chssN <- Chess$new()
chssN$clear()
chssN$moves(verbose = TRUE)

selector_placeN <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chssN$put(piece, "w", spot)
  plot(chssN)
}

selector_moveN <- function(){
  move_num <- sample(1:length(chssN$moves()), 1)
  move_choice <- chssN$moves()[move_num]
  chssN$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chssN$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chssN$put(piece_changer$type, color_change, new_square)
  plot(chssN)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
selector_placeN("n")
replicate(1000, selector_moveN()) ## Repeats moves 1000 times
knight_position <- chssN$history(verbose = TRUE) ## Creates data frame to track
knightDf <- subset(knight_position, to == from[1])
originalKnight <- knightDf[1,7]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
originalKnight
```

###### Queen Functions

```{r message=FALSE, warning=FALSE, include=FALSE}
chssQ <- Chess$new()
chssQ$clear()
chssQ$moves(verbose = TRUE)

selector_placeQ <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chssQ$put(piece, "w", spot)
  plot(chssQ)
}

selector_moveQ <- function(){
  move_num <- sample(1:length(chssQ$moves()), 1)
  move_choice <- chssQ$moves()[move_num]
  chssQ$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chssQ$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chssQ$put(piece_changer$type, color_change, new_square)
  plot(chssQ)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
selector_placeQ("q")
replicate(1000, selector_moveQ()) ## Repeats moves 1000 times
queen_position <- chssQ$history(verbose = TRUE) ## Creates data frame to track position
queenDf <- subset(queen_position, to == from[1]) ## Df with only moves that returned to original position
originalQueen <- queenDf[1,7] ## Df with first turn where piece returned to its original position
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
originalQueen
```

###### King Functions

```{r message=FALSE, warning=FALSE, include=FALSE}
chssK <- Chess$new()
chssK$clear()
chssK$moves(verbose = TRUE)

selector_placeK <- function(piece){
  number <- sample(1:8, 1)
  letter <- sample(letters[1:8], 1)
  spot <- paste(letter, number, sep = "")
  chssK$put(piece, "w", spot)
  plot(chssK)
}

selector_moveK <- function(){
  move_num <- sample(1:length(chssK$moves()), 1)
  move_choice <- chssK$moves()[move_num]
  chssK$move(move_choice)
  new_square <- str_match(move_choice, "[abcdefgh][12345678]")
  piece_changer <- chssK$get(new_square)
  color_change <- ""
  if(piece_changer$color == "w"){
    color_change <- "b"
  }
  else{
    color_change <- "w"
  }
  chssK$put(piece_changer$type, color_change, new_square)
  plot(chssK)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
selector_placeK("k")
replicate(1000, selector_moveK()) ## Repeats moves 1000 times. Function gives back an error FIX ME. length of assertion in not 1
king_position <- chssK$history(verbose = TRUE) ## Creates data frame to track
kingDf <- subset(king_position, to == from[1])
originalKing <- kingDf[1,7]
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
originalKing
```


4. _Visit Some Friends_ Consider two drunken chessmasters playing against each other. They both start with a king and a queen, in the traditional starting positions. They each will take turns making moves at random from all possible legal moves. The players are allowed to "attack" the other player's pieces, and the game stops when a player attacks the other player's King. Simulate this process. (Since these chessmasters are presumably drunk, you may ignore the conditions and rules that place a King into "check".)

5. _Share the Pictures_ Where do the games in part 4 typically end?  How long does it take for these games to end? Create data visualizations to summarize these drunken games.




